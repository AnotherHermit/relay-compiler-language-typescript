// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`TypeScriptGenerator with a single artifact directory matches expected output: conditional.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment ConditionField on Node {
  id @include(if: $condition)
}

fragment NestedCondition on Node {
  ... @include(if: $condition) {
    id
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
declare const _ConditionField$ref: unique symbol;
export type ConditionField$ref = typeof _ConditionField$ref;
export type ConditionField = {
    readonly id?: string;
    readonly " $refType": ConditionField$ref;
};


declare const _NestedCondition$ref: unique symbol;
export type NestedCondition$ref = typeof _NestedCondition$ref;
export type NestedCondition = {
    readonly id?: string;
    readonly " $refType": NestedCondition$ref;
};

`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: derived-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query QueryWithConnectionField($id: ID!) {
  feedback: node(id: $id) {
    ...FeedbackComments_feedback
  }
}

fragment FeedbackComments_feedback on Feedback {
  comments(first: 10)
    @connection_resolver(resolver: "FeedbackCommentsResolver") {
    edges {
      node {
        id
      }
    }
    pageInfo {
      hasNextPage
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'connection_resolver'. Source: document \`FeedbackComments_feedback\` file: \`GraphQL request\`
  
  GraphQL request:9:5
   8 |   comments(first: 10)
   9 |     @connection_resolver(resolver: "FeedbackCommentsResolver") {
     |     ^
  10 |     edges {
`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: fragment-spread.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment FragmentSpread on Node {
  id
  ...OtherFragment
  justFrag: profilePicture {
    ...PictureFragment
  }
  fragAndField: profilePicture {
    uri
    ...PictureFragment
  }
  ... on User {
    ...UserFrag1
    ...UserFrag2
  }
}

fragment ConcreateTypes on Viewer {
  actor {
    __typename
    ... on Page {
      id
      ...PageFragment
    }
    ... on User {
      name
    }
  }
}

fragment PictureFragment on Image {
  __typename
}

fragment OtherFragment on Node {
  __typename
}

fragment PageFragment on Page {
  __typename
}

fragment UserFrag1 on Page {
  __typename
}

fragment UserFrag2 on Page {
  __typename
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
type OtherFragment$ref = any;
type PictureFragment$ref = any;
type UserFrag1$ref = any;
type UserFrag2$ref = any;
declare const _FragmentSpread$ref: unique symbol;
export type FragmentSpread$ref = typeof _FragmentSpread$ref;
export type FragmentSpread = {
    readonly id: string;
    readonly justFrag: {
        readonly " $fragmentRefs": PictureFragment$ref;
    } | null;
    readonly fragAndField: {
        readonly uri: string | null;
        readonly " $fragmentRefs": PictureFragment$ref;
    } | null;
    readonly " $fragmentRefs": OtherFragment$ref & UserFrag1$ref & UserFrag2$ref;
    readonly " $refType": FragmentSpread$ref;
};


type PageFragment$ref = any;
declare const _ConcreateTypes$ref: unique symbol;
export type ConcreateTypes$ref = typeof _ConcreateTypes$ref;
export type ConcreateTypes = {
    readonly actor: ({
        readonly __typename: "Page";
        readonly id: string;
        readonly " $fragmentRefs": PageFragment$ref;
    } | {
        readonly __typename: "User";
        readonly name: string | null;
    } | {
        /*This will never be '%other', but we need some
        value in case none of the concrete values match.*/
        readonly __typename: "%other";
    }) | null;
    readonly " $refType": ConcreateTypes$ref;
};


declare const _PictureFragment$ref: unique symbol;
export type PictureFragment$ref = typeof _PictureFragment$ref;
export type PictureFragment = {
    readonly __typename: "Image";
    readonly " $refType": PictureFragment$ref;
} & ({
    readonly __typename: "Image";
} | {
    /*This will never be '% other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
});


declare const _OtherFragment$ref: unique symbol;
export type OtherFragment$ref = typeof _OtherFragment$ref;
export type OtherFragment = {
    readonly __typename: string;
    readonly " $refType": OtherFragment$ref;
};


declare const _PageFragment$ref: unique symbol;
export type PageFragment$ref = typeof _PageFragment$ref;
export type PageFragment = {
    readonly __typename: "Page";
    readonly " $refType": PageFragment$ref;
} & ({
    readonly __typename: "Page";
} | {
    /*This will never be '% other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
});


declare const _UserFrag1$ref: unique symbol;
export type UserFrag1$ref = typeof _UserFrag1$ref;
export type UserFrag1 = {
    readonly __typename: "Page";
    readonly " $refType": UserFrag1$ref;
} & ({
    readonly __typename: "Page";
} | {
    /*This will never be '% other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
});


declare const _UserFrag2$ref: unique symbol;
export type UserFrag2$ref = typeof _UserFrag2$ref;
export type UserFrag2 = {
    readonly __typename: "Page";
    readonly " $refType": UserFrag2$ref;
} & ({
    readonly __typename: "Page";
} | {
    /*This will never be '% other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
});

`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: inline-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment InlineFragment on Node {
  id
  ... on Actor {
    id
    name
  }
  ... on User {
    message {
      text
    }
  }
}

fragment InlineFragmentWithOverlappingFields on Actor {
  ... on User {
    hometown {
      id
      name
    }
  }
  ... on Page {
    name
    hometown {
      id
      message {
        text
      }
    }
  }
}

fragment InlineFragmentConditionalID on Node {
  ... on Actor {
    id # nullable since it's conditional
    name
  }
}

fragment InlineFragmentKitchenSink on Story {
  actor {
    id
    profilePicture {
      uri
    }
    ... on User {
      id
      name
      ...SomeFragment
      profilePicture {
        width
      }
    }
    ... on Page {
      profilePicture {
        uri
        height
      }
    }
  }
}

fragment SomeFragment on User {
  __typename
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
declare const _InlineFragment$ref: unique symbol;
export type InlineFragment$ref = typeof _InlineFragment$ref;
export type InlineFragment = {
    readonly id: string;
    readonly name?: string | null;
    readonly message?: {
        readonly text: string | null;
    } | null;
    readonly " $refType": InlineFragment$ref;
};


declare const _InlineFragmentWithOverlappingFields$ref: unique symbol;
export type InlineFragmentWithOverlappingFields$ref = typeof _InlineFragmentWithOverlappingFields$ref;
export type InlineFragmentWithOverlappingFields = {
    readonly hometown?: {
        readonly id: string;
        readonly name: string | null;
        readonly message?: {
            readonly text: string | null;
        } | null;
    } | null;
    readonly name?: string | null;
    readonly " $refType": InlineFragmentWithOverlappingFields$ref;
};


declare const _InlineFragmentConditionalID$ref: unique symbol;
export type InlineFragmentConditionalID$ref = typeof _InlineFragmentConditionalID$ref;
export type InlineFragmentConditionalID = {
    readonly id?: string;
    readonly name?: string | null;
    readonly " $refType": InlineFragmentConditionalID$ref;
};


type SomeFragment$ref = any;
declare const _InlineFragmentKitchenSink$ref: unique symbol;
export type InlineFragmentKitchenSink$ref = typeof _InlineFragmentKitchenSink$ref;
export type InlineFragmentKitchenSink = {
    readonly actor: {
        readonly id: string;
        readonly profilePicture: {
            readonly uri: string | null;
            readonly width?: number | null;
            readonly height?: number | null;
        } | null;
        readonly name?: string | null;
        readonly " $fragmentRefs": SomeFragment$ref;
    } | null;
    readonly " $refType": InlineFragmentKitchenSink$ref;
};


declare const _SomeFragment$ref: unique symbol;
export type SomeFragment$ref = typeof _SomeFragment$ref;
export type SomeFragment = {
    readonly __typename: "User";
    readonly " $refType": SomeFragment$ref;
} & ({
    readonly __typename: "User";
} | {
    /*This will never be '% other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
});

`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: linked-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment LinkedField on User {
  profilePicture {
    uri
    width
    height
  }
  hometown {
    # object
    id
    profilePicture {
      uri
    }
  }
  actor {
    # interface
    id
  }
}

query UnionTypeTest {
  neverNode {
    __typename
    ... on FakeNode {
      id
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
declare const _LinkedField$ref: unique symbol;
export type LinkedField$ref = typeof _LinkedField$ref;
export type LinkedField = {
    readonly profilePicture: {
        readonly uri: string | null;
        readonly width: number | null;
        readonly height: number | null;
    } | null;
    readonly hometown: {
        readonly id: string;
        readonly profilePicture: {
            readonly uri: string | null;
        } | null;
    } | null;
    readonly actor: {
        readonly id: string;
    } | null;
    readonly " $refType": LinkedField$ref;
};


export type UnionTypeTestVariables = {};
export type UnionTypeTestResponse = {
    readonly neverNode: ({
        readonly __typename: "FakeNode";
        readonly id: string;
    } | {
        /*This will never be '%other', but we need some
        value in case none of the concrete values match.*/
        readonly __typename: "%other";
    }) | null;
};
export type UnionTypeTest = {
    readonly response: UnionTypeTestResponse;
    readonly variables: UnionTypeTestVariables;
};

`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: match-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment NameRendererFragment on User {
  id
  nameRenderer @match {
    ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
    ...MarkdownUserNameRenderer_name
      @module(name: "MarkdownUserNameRenderer.react")
  }
}

fragment PlainUserNameRenderer_name on PlainUserNameRenderer {
  plaintext
  data {
    text
  }
}

fragment MarkdownUserNameRenderer_name on MarkdownUserNameRenderer {
  markdown
  data {
    markup
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
type MarkdownUserNameRenderer_name$ref = any;
type PlainUserNameRenderer_name$ref = any;
declare const _NameRendererFragment$ref: unique symbol;
export type NameRendererFragment$ref = typeof _NameRendererFragment$ref;
export type NameRendererFragment = {
    readonly id: string;
    readonly nameRenderer: {
        readonly __fragmentPropName?: string | null;
        readonly __module_component?: string | null;
        readonly " $fragmentRefs": PlainUserNameRenderer_name$ref & MarkdownUserNameRenderer_name$ref;
    } | null;
    readonly " $refType": NameRendererFragment$ref;
};


declare const _PlainUserNameRenderer_name$ref: unique symbol;
export type PlainUserNameRenderer_name$ref = typeof _PlainUserNameRenderer_name$ref;
export type PlainUserNameRenderer_name = {
    readonly plaintext: string | null;
    readonly data: {
        readonly text: string | null;
    } | null;
    readonly " $refType": PlainUserNameRenderer_name$ref;
};


declare const _MarkdownUserNameRenderer_name$ref: unique symbol;
export type MarkdownUserNameRenderer_name$ref = typeof _MarkdownUserNameRenderer_name$ref;
export type MarkdownUserNameRenderer_name = {
    readonly markdown: string | null;
    readonly data: {
        readonly markup: string | null;
    } | null;
    readonly " $refType": MarkdownUserNameRenderer_name$ref;
};

`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: match-field-in-query.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query NameRendererQuery {
  me {
    nameRenderer @match {
      ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
      ...MarkdownUserNameRenderer_name
        @module(name: "MarkdownUserNameRenderer.react")
    }
  }
}

fragment PlainUserNameRenderer_name on PlainUserNameRenderer {
  plaintext
  data {
    text
  }
}

fragment MarkdownUserNameRenderer_name on MarkdownUserNameRenderer {
  markdown
  data {
    markup
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
type MarkdownUserNameRenderer_name$ref = any;
type PlainUserNameRenderer_name$ref = any;
export type NameRendererQueryVariables = {};
export type NameRendererQueryResponse = {
    readonly me: {
        readonly nameRenderer: {
            readonly __fragmentPropName?: string | null;
            readonly __module_component?: string | null;
            readonly " $fragmentRefs": PlainUserNameRenderer_name$ref & MarkdownUserNameRenderer_name$ref;
        } | null;
    } | null;
};
export type NameRendererQuery = {
    readonly response: NameRendererQueryResponse;
    readonly variables: NameRendererQueryVariables;
};


declare const _PlainUserNameRenderer_name$ref: unique symbol;
export type PlainUserNameRenderer_name$ref = typeof _PlainUserNameRenderer_name$ref;
export type PlainUserNameRenderer_name = {
    readonly plaintext: string | null;
    readonly data: {
        readonly text: string | null;
    } | null;
    readonly " $refType": PlainUserNameRenderer_name$ref;
};


declare const _MarkdownUserNameRenderer_name$ref: unique symbol;
export type MarkdownUserNameRenderer_name$ref = typeof _MarkdownUserNameRenderer_name$ref;
export type MarkdownUserNameRenderer_name = {
    readonly markdown: string | null;
    readonly data: {
        readonly markup: string | null;
    } | null;
    readonly " $refType": MarkdownUserNameRenderer_name$ref;
};

`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: mutaion-with-client-extension.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation Test($input: UpdateAllSeenStateInput) @raw_response_type {
  viewerNotificationsUpdateAllSeenState(input: $input) {
    stories {
      foos {
        bar
      }
    }
  }
}

extend type Story {
  foos: [Foo]
}

type Foo {
  bar: String
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'raw_response_type'. Source: document \`Test\` file: \`GraphQL request\`
  
  GraphQL request:1:48
  1 | mutation Test($input: UpdateAllSeenStateInput) @raw_response_type {
    |                                                ^
  2 |   viewerNotificationsUpdateAllSeenState(input: $input) {
`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: mutaion-with-response-on-inline-fragments.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation TestMutation($input: CommentCreateInput!) @raw_response_type {
  commentCreate(input: $input) {
    viewer {
      actor {
        ...InlineFragmentWithOverlappingFields
      }
    }
  }
}

fragment InlineFragmentWithOverlappingFields on Actor {
  ... on User {
    hometown {
      id
      name
    }
  }
  ... on Page {
    name
    hometown {
      id
      message {
        text
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'raw_response_type'. Source: document \`TestMutation\` file: \`GraphQL request\`
  
  GraphQL request:1:52
  1 | mutation TestMutation($input: CommentCreateInput!) @raw_response_type {
    |                                                    ^
  2 |   commentCreate(input: $input) {
`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: mutation.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation CommentCreateMutation(
  $input: CommentCreateInput!
  $first: Int
  $orderBy: [String!]
) {
  commentCreate(input: $input) {
    comment {
      id
      name
      friends(first: $first, orderby: $orderBy) {
        count
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
export type CommentCreateInput = {
    readonly clientMutationId?: string | null;
    readonly feedbackId?: string | null;
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentfeedbackFeedback = {
    readonly comment?: FeedbackcommentComment | null;
};
export type FeedbackcommentComment = {
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentCreateMutationVariables = {
    readonly input: CommentCreateInput;
    readonly first?: number | null;
    readonly orderBy?: ReadonlyArray<string> | null;
};
export type CommentCreateMutationResponse = {
    readonly commentCreate: {
        readonly comment: {
            readonly id: string;
            readonly name: string | null;
            readonly friends: {
                readonly count: number | null;
            } | null;
        } | null;
    } | null;
};
export type CommentCreateMutation = {
    readonly response: CommentCreateMutationResponse;
    readonly variables: CommentCreateMutationVariables;
};

`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: mutation-input-has-array.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation InputHasArray($input: UpdateAllSeenStateInput) @raw_response_type {
  viewerNotificationsUpdateAllSeenState(input: $input) {
    stories {
      actorCount
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'raw_response_type'. Source: document \`InputHasArray\` file: \`GraphQL request\`
  
  GraphQL request:1:57
  1 | mutation InputHasArray($input: UpdateAllSeenStateInput) @raw_response_type {
    |                                                         ^
  2 |   viewerNotificationsUpdateAllSeenState(input: $input) {
`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: mutation-with-enums-on-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation CommentCreateMutation(
  $input: CommentCreateInput!
  $first: Int
  $orderBy: [String!]
) @raw_response_type {
  commentCreate(input: $input) {
    comment {
      friends(first: $first, orderby: $orderBy) {
        edges {
          node {
            id
            __typename
            ...FriendFragment
          }
        }
      }
    }
  }
}

fragment FriendFragment on User {
  name
  lastName
  profilePicture2 {
    test_enums
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 2 error(s):
- Unknown directive 'raw_response_type'. Source: document \`CommentCreateMutation\` file: \`GraphQL request\`
  
  GraphQL request:5:3
  4 |   $orderBy: [String!]
  5 | ) @raw_response_type {
    |   ^
  6 |   commentCreate(input: $input) {
- Unknown field 'test_enums' on type 'Image'. Source: document \`FriendFragment\` file: \`GraphQL request\`
  
  GraphQL request:25:5
  24 |   profilePicture2 {
  25 |     test_enums
     |     ^
  26 |   }
`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: mutation-with-nested-fragments.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation CommentCreateMutation(
  $input: CommentCreateInput!
  $first: Int
  $orderBy: [String!]
) @raw_response_type {
  commentCreate(input: $input) {
    comment {
      friends(first: $first, orderby: $orderBy) {
        edges {
          node {
            lastName
            ...FriendFragment
          }
        }
      }
    }
  }
}

fragment FriendFragment on User {
  name
  lastName
  feedback {
    ...FeedbackFragment
  }
}

fragment FeedbackFragment on Feedback {
  id
  name
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'raw_response_type'. Source: document \`CommentCreateMutation\` file: \`GraphQL request\`
  
  GraphQL request:5:3
  4 |   $orderBy: [String!]
  5 | ) @raw_response_type {
    |   ^
  6 |   commentCreate(input: $input) {
`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: plural-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment PluralFragment on Node @relay(plural: true) {
  id
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
declare const _PluralFragment$ref: unique symbol;
export type PluralFragment$ref = typeof _PluralFragment$ref;
export type PluralFragment = ReadonlyArray<{
    readonly id: string;
    readonly " $refType": PluralFragment$ref;
}>;

`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: query-with-defer.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query TestDefer @raw_response_type {
  node(id: "1") {
    ... on User {
      name
      friends(first: 10) {
        edges {
          ... on FriendsConnection @defer {
            pageInfo {
              endCursor
              hasNextPage
            }
          }
        }
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'raw_response_type'. Source: document \`TestDefer\` file: \`GraphQL request\`
  
  GraphQL request:1:17
  1 | query TestDefer @raw_response_type {
    |                 ^
  2 |   node(id: "1") {
`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: query-with-handles.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query LinkedHandleField($id: ID!) @raw_response_type {
  node(id: $id) {
    ... on User {
      friends(first: 10) @__clientField(handle: "clientFriends") {
        count
      }
    }
  }
}

query ScalarHandleField($id: ID!) @raw_response_type {
  node(id: $id) {
    ... on User {
      name @__clientField(handle: "clientName")
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 2 error(s):
- Unknown directive 'raw_response_type'. Source: document \`LinkedHandleField\` file: \`GraphQL request\`
  
  GraphQL request:1:35
  1 | query LinkedHandleField($id: ID!) @raw_response_type {
    |                                   ^
  2 |   node(id: $id) {
- Unknown directive 'raw_response_type'. Source: document \`ScalarHandleField\` file: \`GraphQL request\`
  
  GraphQL request:11:35
  10 | 
  11 | query ScalarHandleField($id: ID!) @raw_response_type {
     |                                   ^
  12 |   node(id: $id) {
`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: query-with-match-fields.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query Test @raw_response_type {
  node(id: "1") {
    ...NameRendererFragment
  }
}

fragment NameRendererFragment on User {
  id
  nameRenderer @match {
    ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
    ...MarkdownUserNameRenderer_name
      @module(name: "MarkdownUserNameRenderer.react")
  }
}

fragment PlainUserNameRenderer_name on PlainUserNameRenderer {
  plaintext
  data {
    text
  }
}

fragment MarkdownUserNameRenderer_name on MarkdownUserNameRenderer {
  markdown
  data {
    markup
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'raw_response_type'. Source: document \`Test\` file: \`GraphQL request\`
  
  GraphQL request:1:12
  1 | query Test @raw_response_type {
    |            ^
  2 |   node(id: "1") {
`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: query-with-multiple-match-fields.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query Test @raw_response_type {
  node(id: "1") {
    ... on User {
      username
      ...NameRendererFragment
    }
  }
  viewer {
    ... on User {
      name
      ...AnotherNameRendererFragment
    }
  }
}

fragment NameRendererFragment on User {
  id
  nameRenderer @match {
    ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
    ...MarkdownUserNameRenderer_name
      @module(name: "MarkdownUserNameRenderer.react")
  }
}

fragment AnotherNameRendererFragment on User {
  name
  nameRenderer @match {
    ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
    ...MarkdownUserNameRenderer_name
      @module(name: "MarkdownUserNameRenderer.react")
  }
}

fragment PlainUserNameRenderer_name on PlainUserNameRenderer {
  plaintext
  data {
    text
  }
}

fragment MarkdownUserNameRenderer_name on MarkdownUserNameRenderer {
  markdown
  data {
    markup
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'raw_response_type'. Source: document \`Test\` file: \`GraphQL request\`
  
  GraphQL request:1:12
  1 | query Test @raw_response_type {
    |            ^
  2 |   node(id: "1") {
`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: query-with-raw-response-on-conditional.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query ExampleQuery($id: ID!, $condition: Boolean!) @raw_response_type {
  node(id: $id) {
    ...FriendFragment
  }
}

fragment FriendFragment on User {
  ... @include(if: $condition) {
    name
    lastName
    feedback {
      id
      name
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'raw_response_type'. Source: document \`ExampleQuery\` file: \`GraphQL request\`
  
  GraphQL request:1:52
  1 | query ExampleQuery($id: ID!, $condition: Boolean!) @raw_response_type {
    |                                                    ^
  2 |   node(id: $id) {
`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: query-with-stream.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query TestStream @raw_response_type {
  node(id: "1") {
    ... on User {
      name
      friends(first: 10)
        @stream_connection(
          key: "PaginationFragment_friends"
          initial_count: 1
        ) {
        edges {
          node {
            id
          }
        }
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'raw_response_type'. Source: document \`TestStream\` file: \`GraphQL request\`
  
  GraphQL request:1:18
  1 | query TestStream @raw_response_type {
    |                  ^
  2 |   node(id: "1") {
`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: recursive-fragments.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment FragmentSpread on Node {
  id
  ... @include(if: $condition) {
    ...FragmentSpread
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
type FragmentSpread$ref = any;
declare const _FragmentSpread$ref: unique symbol;
export type FragmentSpread$ref = typeof _FragmentSpread$ref;
export type FragmentSpread = {
    readonly id: string;
    readonly " $fragmentRefs": FragmentSpread$ref;
    readonly " $refType": FragmentSpread$ref;
};

`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: refetchable-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment RefetchableFragment on Node
  @refetchable(queryName: "RefetchableFragmentQuery") {
  id
  fragAndField: profilePicture {
    uri
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'refetchable'. Source: document \`RefetchableFragment\` file: \`GraphQL request\`
  
  GraphQL request:2:3
  1 | fragment RefetchableFragment on Node
  2 |   @refetchable(queryName: "RefetchableFragmentQuery") {
    |   ^
  3 |   id
`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: roots.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query ExampleQuery($id: ID!) {
  node(id: $id) {
    id
  }
}

fragment ExampleFragment on User {
  id
}

mutation TestMutation($input: CommentCreateInput!) {
  commentCreate(input: $input) {
    comment {
      id
    }
  }
}

subscription TestSubscription($input: FeedbackLikeInput) {
  feedbackLikeSubscribe(input: $input) {
    feedback {
      id
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
export type ExampleQueryVariables = {
    readonly id: string;
};
export type ExampleQueryResponse = {
    readonly node: {
        readonly id: string;
    } | null;
};
export type ExampleQuery = {
    readonly response: ExampleQueryResponse;
    readonly variables: ExampleQueryVariables;
};


declare const _ExampleFragment$ref: unique symbol;
export type ExampleFragment$ref = typeof _ExampleFragment$ref;
export type ExampleFragment = {
    readonly id: string;
    readonly " $refType": ExampleFragment$ref;
};


export type CommentCreateInput = {
    readonly clientMutationId?: string | null;
    readonly feedbackId?: string | null;
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentfeedbackFeedback = {
    readonly comment?: FeedbackcommentComment | null;
};
export type FeedbackcommentComment = {
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type TestMutationVariables = {
    readonly input: CommentCreateInput;
};
export type TestMutationResponse = {
    readonly commentCreate: {
        readonly comment: {
            readonly id: string;
        } | null;
    } | null;
};
export type TestMutation = {
    readonly response: TestMutationResponse;
    readonly variables: TestMutationVariables;
};


export type FeedbackLikeInput = {
    readonly clientMutationId?: string | null;
    readonly feedbackId?: string | null;
};
export type TestSubscriptionVariables = {
    readonly input?: FeedbackLikeInput | null;
};
export type TestSubscriptionResponse = {
    readonly feedbackLikeSubscribe: {
        readonly feedback: {
            readonly id: string;
        } | null;
    } | null;
};
export type TestSubscription = {
    readonly response: TestSubscriptionResponse;
    readonly variables: TestSubscriptionVariables;
};

`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: scalar-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment ScalarField on User {
  id
  name
  websites
  traits
  aliasedLinkedField: birthdate {
    aliasedField: year
  }
  screennames {
    name
    service
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
export type PersonalityTraits = "CHEERFUL" | "DERISIVE" | "HELPFUL" | "SNARKY" | "%future added value";
declare const _ScalarField$ref: unique symbol;
export type ScalarField$ref = typeof _ScalarField$ref;
export type ScalarField = {
    readonly id: string;
    readonly name: string | null;
    readonly websites: ReadonlyArray<string | null> | null;
    readonly traits: ReadonlyArray<PersonalityTraits | null> | null;
    readonly aliasedLinkedField: {
        readonly aliasedField: number | null;
    } | null;
    readonly screennames: ReadonlyArray<{
        readonly name: string | null;
        readonly service: string | null;
    } | null> | null;
    readonly " $refType": ScalarField$ref;
};

`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: typename-inside-with-overlapping-fields.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment TypenameInsideWithOverlappingFields on Viewer {
  actor {
    __typename
    ... on Page {
      id
      name
    }
    ... on User {
      id
      name
      profile_picture {
        uri
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
declare const _TypenameInsideWithOverlappingFields$ref: unique symbol;
export type TypenameInsideWithOverlappingFields$ref = typeof _TypenameInsideWithOverlappingFields$ref;
export type TypenameInsideWithOverlappingFields = {
    readonly actor: ({
        readonly __typename: "Page";
        readonly id: string;
        readonly name: string | null;
    } | {
        readonly __typename: "User";
        readonly id: string;
        readonly name: string | null;
        readonly profile_picture: {
            readonly uri: string | null;
        } | null;
    } | {
        /*This will never be '%other', but we need some
        value in case none of the concrete values match.*/
        readonly __typename: "%other";
    }) | null;
    readonly " $refType": TypenameInsideWithOverlappingFields$ref;
};

`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: typename-inside-with-overlapping-fields-full.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment TypenameInsideWithOverlappingFieldsFull on Viewer {
  actor {
    __typename
    ... on Page {
      id
      name
    }
    ... on User {
      id
      name
      profile_picture {
        uri
      }
    }
    ... on ExtraUser {
      id
      name
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
declare const _TypenameInsideWithOverlappingFieldsFull$ref: unique symbol;
export type TypenameInsideWithOverlappingFieldsFull$ref = typeof _TypenameInsideWithOverlappingFieldsFull$ref;
export type TypenameInsideWithOverlappingFieldsFull = {
    readonly actor: ({
        readonly __typename: "Page";
        readonly id: string;
        readonly name: string | null;
    } | {
        readonly __typename: "User";
        readonly id: string;
        readonly name: string | null;
        readonly profile_picture: {
            readonly uri: string | null;
        } | null;
    } | {
        readonly __typename: "ExtraUser";
        readonly id: string;
        readonly name: string | null;
    } | {
        /*This will never be '%other', but we need some
        value in case none of the concrete values match.*/
        readonly __typename: "%other";
    }) | null;
    readonly " $refType": TypenameInsideWithOverlappingFieldsFull$ref;
};

`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: typename-on-union.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment TypenameInside on Actor {
  ... on User {
    __typename
    firstName
  }
  ... on Page {
    __typename
    username
  }
}

fragment TypenameOutside on Actor {
  __typename
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

fragment TypenameOutsideWithAbstractType on Node {
  __typename
  ... on User {
    firstName
    address {
      street # only here
      city # common
    }
  }
  ... on Actor {
    username
    address {
      city # common
      country # only here
    }
  }
}

fragment TypenameWithoutSpreads on User {
  __typename
  firstName
}

fragment TypenameWithoutSpreadsAbstractType on Node {
  __typename
  id
}

fragment TypenameWithCommonSelections on Actor {
  __typename
  name
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

fragment TypenameAlias on Actor {
  _typeAlias: __typename
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

fragment TypenameAliases on Actor {
  _typeAlias1: __typename
  _typeAlias2: __typename
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
declare const _TypenameInside$ref: unique symbol;
export type TypenameInside$ref = typeof _TypenameInside$ref;
export type TypenameInside = {
    readonly __typename: "User";
    readonly firstName: string | null;
    readonly " $refType": TypenameInside$ref;
} | {
    readonly __typename: "Page";
    readonly username: string | null;
    readonly " $refType": TypenameInside$ref;
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
    readonly " $refType": TypenameInside$ref;
};


declare const _TypenameOutside$ref: unique symbol;
export type TypenameOutside$ref = typeof _TypenameOutside$ref;
export type TypenameOutside = {
    readonly __typename: "User";
    readonly firstName: string | null;
    readonly " $refType": TypenameOutside$ref;
} | {
    readonly __typename: "Page";
    readonly username: string | null;
    readonly " $refType": TypenameOutside$ref;
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
    readonly " $refType": TypenameOutside$ref;
};


declare const _TypenameOutsideWithAbstractType$ref: unique symbol;
export type TypenameOutsideWithAbstractType$ref = typeof _TypenameOutsideWithAbstractType$ref;
export type TypenameOutsideWithAbstractType = {
    readonly __typename: string;
    readonly username?: string | null;
    readonly address?: {
        readonly city: string | null;
        readonly country: string | null;
        readonly street?: string | null;
    } | null;
    readonly firstName?: string | null;
    readonly " $refType": TypenameOutsideWithAbstractType$ref;
};


declare const _TypenameWithoutSpreads$ref: unique symbol;
export type TypenameWithoutSpreads$ref = typeof _TypenameWithoutSpreads$ref;
export type TypenameWithoutSpreads = {
    readonly firstName: string | null;
    readonly __typename: "User";
    readonly " $refType": TypenameWithoutSpreads$ref;
};


declare const _TypenameWithoutSpreadsAbstractType$ref: unique symbol;
export type TypenameWithoutSpreadsAbstractType$ref = typeof _TypenameWithoutSpreadsAbstractType$ref;
export type TypenameWithoutSpreadsAbstractType = {
    readonly __typename: string;
    readonly id: string;
    readonly " $refType": TypenameWithoutSpreadsAbstractType$ref;
};


declare const _TypenameWithCommonSelections$ref: unique symbol;
export type TypenameWithCommonSelections$ref = typeof _TypenameWithCommonSelections$ref;
export type TypenameWithCommonSelections = {
    readonly __typename: string;
    readonly name: string | null;
    readonly firstName?: string | null;
    readonly username?: string | null;
    readonly " $refType": TypenameWithCommonSelections$ref;
};


declare const _TypenameAlias$ref: unique symbol;
export type TypenameAlias$ref = typeof _TypenameAlias$ref;
export type TypenameAlias = {
    readonly _typeAlias: "User";
    readonly firstName: string | null;
    readonly " $refType": TypenameAlias$ref;
} | {
    readonly _typeAlias: "Page";
    readonly username: string | null;
    readonly " $refType": TypenameAlias$ref;
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly _typeAlias: "%other";
    readonly " $refType": TypenameAlias$ref;
};


declare const _TypenameAliases$ref: unique symbol;
export type TypenameAliases$ref = typeof _TypenameAliases$ref;
export type TypenameAliases = {
    readonly _typeAlias1: "User";
    readonly _typeAlias2: "User";
    readonly firstName: string | null;
    readonly " $refType": TypenameAliases$ref;
} | {
    readonly _typeAlias1: "Page";
    readonly _typeAlias2: "Page";
    readonly username: string | null;
    readonly " $refType": TypenameAliases$ref;
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly _typeAlias1: "%other";
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly _typeAlias2: "%other";
    readonly " $refType": TypenameAliases$ref;
};

`;

exports[`TypeScriptGenerator with a single artifact directory matches expected output: unmasked-fragment-spreads.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment UserProfile on User {
  profilePicture(size: $ProfilePicture_SIZE) {
    ...PhotoFragment @relay(mask: false)

    # duplicated field should be merged
    ...AnotherRecursiveFragment @relay(mask: false)

    # Compose child fragment
    ...PhotoFragment
  }
}

fragment PhotoFragment on Image {
  uri
  ...RecursiveFragment @relay(mask: false)
}

fragment RecursiveFragment on Image @relay(mask: false) {
  uri
  width
}

fragment AnotherRecursiveFragment on Image {
  uri
  height
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
import { PhotoFragment$ref } from "./PhotoFragment.graphql";
declare const _UserProfile$ref: unique symbol;
export type UserProfile$ref = typeof _UserProfile$ref;
export type UserProfile = {
    readonly profilePicture: {
        readonly uri: string | null;
        readonly width: number | null;
        readonly height: number | null;
        readonly " $fragmentRefs": PhotoFragment$ref;
    } | null;
    readonly " $refType": UserProfile$ref;
};


declare const _PhotoFragment$ref: unique symbol;
export type PhotoFragment$ref = typeof _PhotoFragment$ref;
export type PhotoFragment = {
    readonly uri: string | null;
    readonly width: number | null;
    readonly " $refType": PhotoFragment$ref;
};


declare const _RecursiveFragment$ref: unique symbol;
export type RecursiveFragment$ref = typeof _RecursiveFragment$ref;
export type RecursiveFragment = {
    readonly uri: string | null;
    readonly width: number | null;
};


declare const _AnotherRecursiveFragment$ref: unique symbol;
export type AnotherRecursiveFragment$ref = typeof _AnotherRecursiveFragment$ref;
export type AnotherRecursiveFragment = {
    readonly uri: string | null;
    readonly height: number | null;
    readonly " $refType": AnotherRecursiveFragment$ref;
};

`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: conditional.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment ConditionField on Node {
  id @include(if: $condition)
}

fragment NestedCondition on Node {
  ... @include(if: $condition) {
    id
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
export type ConditionField$ref = any;
export type ConditionField = {
    readonly id?: string;
    readonly " $refType": ConditionField$ref;
};


export type NestedCondition$ref = any;
export type NestedCondition = {
    readonly id?: string;
    readonly " $refType": NestedCondition$ref;
};

`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: derived-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query QueryWithConnectionField($id: ID!) {
  feedback: node(id: $id) {
    ...FeedbackComments_feedback
  }
}

fragment FeedbackComments_feedback on Feedback {
  comments(first: 10)
    @connection_resolver(resolver: "FeedbackCommentsResolver") {
    edges {
      node {
        id
      }
    }
    pageInfo {
      hasNextPage
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'connection_resolver'. Source: document \`FeedbackComments_feedback\` file: \`GraphQL request\`
  
  GraphQL request:9:5
   8 |   comments(first: 10)
   9 |     @connection_resolver(resolver: "FeedbackCommentsResolver") {
     |     ^
  10 |     edges {
`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: fragment-spread.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment FragmentSpread on Node {
  id
  ...OtherFragment
  justFrag: profilePicture {
    ...PictureFragment
  }
  fragAndField: profilePicture {
    uri
    ...PictureFragment
  }
  ... on User {
    ...UserFrag1
    ...UserFrag2
  }
}

fragment ConcreateTypes on Viewer {
  actor {
    __typename
    ... on Page {
      id
      ...PageFragment
    }
    ... on User {
      name
    }
  }
}

fragment PictureFragment on Image {
  __typename
}

fragment OtherFragment on Node {
  __typename
}

fragment PageFragment on Page {
  __typename
}

fragment UserFrag1 on Page {
  __typename
}

fragment UserFrag2 on Page {
  __typename
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
type OtherFragment$ref = any;
type PictureFragment$ref = any;
type UserFrag1$ref = any;
type UserFrag2$ref = any;
export type FragmentSpread$ref = any;
export type FragmentSpread = {
    readonly id: string;
    readonly justFrag: {
        readonly " $fragmentRefs": PictureFragment$ref;
    } | null;
    readonly fragAndField: {
        readonly uri: string | null;
        readonly " $fragmentRefs": PictureFragment$ref;
    } | null;
    readonly " $fragmentRefs": OtherFragment$ref & UserFrag1$ref & UserFrag2$ref;
    readonly " $refType": FragmentSpread$ref;
};


type PageFragment$ref = any;
export type ConcreateTypes$ref = any;
export type ConcreateTypes = {
    readonly actor: ({
        readonly __typename: "Page";
        readonly id: string;
        readonly " $fragmentRefs": PageFragment$ref;
    } | {
        readonly __typename: "User";
        readonly name: string | null;
    } | {
        /*This will never be '%other', but we need some
        value in case none of the concrete values match.*/
        readonly __typename: "%other";
    }) | null;
    readonly " $refType": ConcreateTypes$ref;
};


export type PictureFragment$ref = any;
export type PictureFragment = {
    readonly __typename: "Image";
    readonly " $refType": PictureFragment$ref;
} & ({
    readonly __typename: "Image";
} | {
    /*This will never be '% other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
});


export type OtherFragment$ref = any;
export type OtherFragment = {
    readonly __typename: string;
    readonly " $refType": OtherFragment$ref;
};


export type PageFragment$ref = any;
export type PageFragment = {
    readonly __typename: "Page";
    readonly " $refType": PageFragment$ref;
} & ({
    readonly __typename: "Page";
} | {
    /*This will never be '% other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
});


export type UserFrag1$ref = any;
export type UserFrag1 = {
    readonly __typename: "Page";
    readonly " $refType": UserFrag1$ref;
} & ({
    readonly __typename: "Page";
} | {
    /*This will never be '% other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
});


export type UserFrag2$ref = any;
export type UserFrag2 = {
    readonly __typename: "Page";
    readonly " $refType": UserFrag2$ref;
} & ({
    readonly __typename: "Page";
} | {
    /*This will never be '% other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
});

`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: inline-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment InlineFragment on Node {
  id
  ... on Actor {
    id
    name
  }
  ... on User {
    message {
      text
    }
  }
}

fragment InlineFragmentWithOverlappingFields on Actor {
  ... on User {
    hometown {
      id
      name
    }
  }
  ... on Page {
    name
    hometown {
      id
      message {
        text
      }
    }
  }
}

fragment InlineFragmentConditionalID on Node {
  ... on Actor {
    id # nullable since it's conditional
    name
  }
}

fragment InlineFragmentKitchenSink on Story {
  actor {
    id
    profilePicture {
      uri
    }
    ... on User {
      id
      name
      ...SomeFragment
      profilePicture {
        width
      }
    }
    ... on Page {
      profilePicture {
        uri
        height
      }
    }
  }
}

fragment SomeFragment on User {
  __typename
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
export type InlineFragment$ref = any;
export type InlineFragment = {
    readonly id: string;
    readonly name?: string | null;
    readonly message?: {
        readonly text: string | null;
    } | null;
    readonly " $refType": InlineFragment$ref;
};


export type InlineFragmentWithOverlappingFields$ref = any;
export type InlineFragmentWithOverlappingFields = {
    readonly hometown?: {
        readonly id: string;
        readonly name: string | null;
        readonly message?: {
            readonly text: string | null;
        } | null;
    } | null;
    readonly name?: string | null;
    readonly " $refType": InlineFragmentWithOverlappingFields$ref;
};


export type InlineFragmentConditionalID$ref = any;
export type InlineFragmentConditionalID = {
    readonly id?: string;
    readonly name?: string | null;
    readonly " $refType": InlineFragmentConditionalID$ref;
};


type SomeFragment$ref = any;
export type InlineFragmentKitchenSink$ref = any;
export type InlineFragmentKitchenSink = {
    readonly actor: {
        readonly id: string;
        readonly profilePicture: {
            readonly uri: string | null;
            readonly width?: number | null;
            readonly height?: number | null;
        } | null;
        readonly name?: string | null;
        readonly " $fragmentRefs": SomeFragment$ref;
    } | null;
    readonly " $refType": InlineFragmentKitchenSink$ref;
};


export type SomeFragment$ref = any;
export type SomeFragment = {
    readonly __typename: "User";
    readonly " $refType": SomeFragment$ref;
} & ({
    readonly __typename: "User";
} | {
    /*This will never be '% other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
});

`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: linked-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment LinkedField on User {
  profilePicture {
    uri
    width
    height
  }
  hometown {
    # object
    id
    profilePicture {
      uri
    }
  }
  actor {
    # interface
    id
  }
}

query UnionTypeTest {
  neverNode {
    __typename
    ... on FakeNode {
      id
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
export type LinkedField$ref = any;
export type LinkedField = {
    readonly profilePicture: {
        readonly uri: string | null;
        readonly width: number | null;
        readonly height: number | null;
    } | null;
    readonly hometown: {
        readonly id: string;
        readonly profilePicture: {
            readonly uri: string | null;
        } | null;
    } | null;
    readonly actor: {
        readonly id: string;
    } | null;
    readonly " $refType": LinkedField$ref;
};


export type UnionTypeTestVariables = {};
export type UnionTypeTestResponse = {
    readonly neverNode: ({
        readonly __typename: "FakeNode";
        readonly id: string;
    } | {
        /*This will never be '%other', but we need some
        value in case none of the concrete values match.*/
        readonly __typename: "%other";
    }) | null;
};
export type UnionTypeTest = {
    readonly response: UnionTypeTestResponse;
    readonly variables: UnionTypeTestVariables;
};

`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: match-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment NameRendererFragment on User {
  id
  nameRenderer @match {
    ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
    ...MarkdownUserNameRenderer_name
      @module(name: "MarkdownUserNameRenderer.react")
  }
}

fragment PlainUserNameRenderer_name on PlainUserNameRenderer {
  plaintext
  data {
    text
  }
}

fragment MarkdownUserNameRenderer_name on MarkdownUserNameRenderer {
  markdown
  data {
    markup
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
type MarkdownUserNameRenderer_name$ref = any;
type PlainUserNameRenderer_name$ref = any;
export type NameRendererFragment$ref = any;
export type NameRendererFragment = {
    readonly id: string;
    readonly nameRenderer: {
        readonly __fragmentPropName?: string | null;
        readonly __module_component?: string | null;
        readonly " $fragmentRefs": PlainUserNameRenderer_name$ref & MarkdownUserNameRenderer_name$ref;
    } | null;
    readonly " $refType": NameRendererFragment$ref;
};


export type PlainUserNameRenderer_name$ref = any;
export type PlainUserNameRenderer_name = {
    readonly plaintext: string | null;
    readonly data: {
        readonly text: string | null;
    } | null;
    readonly " $refType": PlainUserNameRenderer_name$ref;
};


export type MarkdownUserNameRenderer_name$ref = any;
export type MarkdownUserNameRenderer_name = {
    readonly markdown: string | null;
    readonly data: {
        readonly markup: string | null;
    } | null;
    readonly " $refType": MarkdownUserNameRenderer_name$ref;
};

`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: match-field-in-query.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query NameRendererQuery {
  me {
    nameRenderer @match {
      ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
      ...MarkdownUserNameRenderer_name
        @module(name: "MarkdownUserNameRenderer.react")
    }
  }
}

fragment PlainUserNameRenderer_name on PlainUserNameRenderer {
  plaintext
  data {
    text
  }
}

fragment MarkdownUserNameRenderer_name on MarkdownUserNameRenderer {
  markdown
  data {
    markup
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
type MarkdownUserNameRenderer_name$ref = any;
type PlainUserNameRenderer_name$ref = any;
export type NameRendererQueryVariables = {};
export type NameRendererQueryResponse = {
    readonly me: {
        readonly nameRenderer: {
            readonly __fragmentPropName?: string | null;
            readonly __module_component?: string | null;
            readonly " $fragmentRefs": PlainUserNameRenderer_name$ref & MarkdownUserNameRenderer_name$ref;
        } | null;
    } | null;
};
export type NameRendererQuery = {
    readonly response: NameRendererQueryResponse;
    readonly variables: NameRendererQueryVariables;
};


export type PlainUserNameRenderer_name$ref = any;
export type PlainUserNameRenderer_name = {
    readonly plaintext: string | null;
    readonly data: {
        readonly text: string | null;
    } | null;
    readonly " $refType": PlainUserNameRenderer_name$ref;
};


export type MarkdownUserNameRenderer_name$ref = any;
export type MarkdownUserNameRenderer_name = {
    readonly markdown: string | null;
    readonly data: {
        readonly markup: string | null;
    } | null;
    readonly " $refType": MarkdownUserNameRenderer_name$ref;
};

`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: mutaion-with-client-extension.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation Test($input: UpdateAllSeenStateInput) @raw_response_type {
  viewerNotificationsUpdateAllSeenState(input: $input) {
    stories {
      foos {
        bar
      }
    }
  }
}

extend type Story {
  foos: [Foo]
}

type Foo {
  bar: String
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'raw_response_type'. Source: document \`Test\` file: \`GraphQL request\`
  
  GraphQL request:1:48
  1 | mutation Test($input: UpdateAllSeenStateInput) @raw_response_type {
    |                                                ^
  2 |   viewerNotificationsUpdateAllSeenState(input: $input) {
`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: mutaion-with-response-on-inline-fragments.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation TestMutation($input: CommentCreateInput!) @raw_response_type {
  commentCreate(input: $input) {
    viewer {
      actor {
        ...InlineFragmentWithOverlappingFields
      }
    }
  }
}

fragment InlineFragmentWithOverlappingFields on Actor {
  ... on User {
    hometown {
      id
      name
    }
  }
  ... on Page {
    name
    hometown {
      id
      message {
        text
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'raw_response_type'. Source: document \`TestMutation\` file: \`GraphQL request\`
  
  GraphQL request:1:52
  1 | mutation TestMutation($input: CommentCreateInput!) @raw_response_type {
    |                                                    ^
  2 |   commentCreate(input: $input) {
`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: mutation.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation CommentCreateMutation(
  $input: CommentCreateInput!
  $first: Int
  $orderBy: [String!]
) {
  commentCreate(input: $input) {
    comment {
      id
      name
      friends(first: $first, orderby: $orderBy) {
        count
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
export type CommentCreateInput = {
    readonly clientMutationId?: string | null;
    readonly feedbackId?: string | null;
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentfeedbackFeedback = {
    readonly comment?: FeedbackcommentComment | null;
};
export type FeedbackcommentComment = {
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentCreateMutationVariables = {
    readonly input: CommentCreateInput;
    readonly first?: number | null;
    readonly orderBy?: ReadonlyArray<string> | null;
};
export type CommentCreateMutationResponse = {
    readonly commentCreate: {
        readonly comment: {
            readonly id: string;
            readonly name: string | null;
            readonly friends: {
                readonly count: number | null;
            } | null;
        } | null;
    } | null;
};
export type CommentCreateMutation = {
    readonly response: CommentCreateMutationResponse;
    readonly variables: CommentCreateMutationVariables;
};

`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: mutation-input-has-array.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation InputHasArray($input: UpdateAllSeenStateInput) @raw_response_type {
  viewerNotificationsUpdateAllSeenState(input: $input) {
    stories {
      actorCount
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'raw_response_type'. Source: document \`InputHasArray\` file: \`GraphQL request\`
  
  GraphQL request:1:57
  1 | mutation InputHasArray($input: UpdateAllSeenStateInput) @raw_response_type {
    |                                                         ^
  2 |   viewerNotificationsUpdateAllSeenState(input: $input) {
`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: mutation-with-enums-on-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation CommentCreateMutation(
  $input: CommentCreateInput!
  $first: Int
  $orderBy: [String!]
) @raw_response_type {
  commentCreate(input: $input) {
    comment {
      friends(first: $first, orderby: $orderBy) {
        edges {
          node {
            id
            __typename
            ...FriendFragment
          }
        }
      }
    }
  }
}

fragment FriendFragment on User {
  name
  lastName
  profilePicture2 {
    test_enums
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 2 error(s):
- Unknown directive 'raw_response_type'. Source: document \`CommentCreateMutation\` file: \`GraphQL request\`
  
  GraphQL request:5:3
  4 |   $orderBy: [String!]
  5 | ) @raw_response_type {
    |   ^
  6 |   commentCreate(input: $input) {
- Unknown field 'test_enums' on type 'Image'. Source: document \`FriendFragment\` file: \`GraphQL request\`
  
  GraphQL request:25:5
  24 |   profilePicture2 {
  25 |     test_enums
     |     ^
  26 |   }
`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: mutation-with-nested-fragments.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation CommentCreateMutation(
  $input: CommentCreateInput!
  $first: Int
  $orderBy: [String!]
) @raw_response_type {
  commentCreate(input: $input) {
    comment {
      friends(first: $first, orderby: $orderBy) {
        edges {
          node {
            lastName
            ...FriendFragment
          }
        }
      }
    }
  }
}

fragment FriendFragment on User {
  name
  lastName
  feedback {
    ...FeedbackFragment
  }
}

fragment FeedbackFragment on Feedback {
  id
  name
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'raw_response_type'. Source: document \`CommentCreateMutation\` file: \`GraphQL request\`
  
  GraphQL request:5:3
  4 |   $orderBy: [String!]
  5 | ) @raw_response_type {
    |   ^
  6 |   commentCreate(input: $input) {
`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: plural-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment PluralFragment on Node @relay(plural: true) {
  id
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
export type PluralFragment$ref = any;
export type PluralFragment = ReadonlyArray<{
    readonly id: string;
    readonly " $refType": PluralFragment$ref;
}>;

`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: query-with-defer.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query TestDefer @raw_response_type {
  node(id: "1") {
    ... on User {
      name
      friends(first: 10) {
        edges {
          ... on FriendsConnection @defer {
            pageInfo {
              endCursor
              hasNextPage
            }
          }
        }
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'raw_response_type'. Source: document \`TestDefer\` file: \`GraphQL request\`
  
  GraphQL request:1:17
  1 | query TestDefer @raw_response_type {
    |                 ^
  2 |   node(id: "1") {
`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: query-with-handles.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query LinkedHandleField($id: ID!) @raw_response_type {
  node(id: $id) {
    ... on User {
      friends(first: 10) @__clientField(handle: "clientFriends") {
        count
      }
    }
  }
}

query ScalarHandleField($id: ID!) @raw_response_type {
  node(id: $id) {
    ... on User {
      name @__clientField(handle: "clientName")
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 2 error(s):
- Unknown directive 'raw_response_type'. Source: document \`LinkedHandleField\` file: \`GraphQL request\`
  
  GraphQL request:1:35
  1 | query LinkedHandleField($id: ID!) @raw_response_type {
    |                                   ^
  2 |   node(id: $id) {
- Unknown directive 'raw_response_type'. Source: document \`ScalarHandleField\` file: \`GraphQL request\`
  
  GraphQL request:11:35
  10 | 
  11 | query ScalarHandleField($id: ID!) @raw_response_type {
     |                                   ^
  12 |   node(id: $id) {
`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: query-with-match-fields.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query Test @raw_response_type {
  node(id: "1") {
    ...NameRendererFragment
  }
}

fragment NameRendererFragment on User {
  id
  nameRenderer @match {
    ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
    ...MarkdownUserNameRenderer_name
      @module(name: "MarkdownUserNameRenderer.react")
  }
}

fragment PlainUserNameRenderer_name on PlainUserNameRenderer {
  plaintext
  data {
    text
  }
}

fragment MarkdownUserNameRenderer_name on MarkdownUserNameRenderer {
  markdown
  data {
    markup
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'raw_response_type'. Source: document \`Test\` file: \`GraphQL request\`
  
  GraphQL request:1:12
  1 | query Test @raw_response_type {
    |            ^
  2 |   node(id: "1") {
`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: query-with-multiple-match-fields.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query Test @raw_response_type {
  node(id: "1") {
    ... on User {
      username
      ...NameRendererFragment
    }
  }
  viewer {
    ... on User {
      name
      ...AnotherNameRendererFragment
    }
  }
}

fragment NameRendererFragment on User {
  id
  nameRenderer @match {
    ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
    ...MarkdownUserNameRenderer_name
      @module(name: "MarkdownUserNameRenderer.react")
  }
}

fragment AnotherNameRendererFragment on User {
  name
  nameRenderer @match {
    ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
    ...MarkdownUserNameRenderer_name
      @module(name: "MarkdownUserNameRenderer.react")
  }
}

fragment PlainUserNameRenderer_name on PlainUserNameRenderer {
  plaintext
  data {
    text
  }
}

fragment MarkdownUserNameRenderer_name on MarkdownUserNameRenderer {
  markdown
  data {
    markup
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'raw_response_type'. Source: document \`Test\` file: \`GraphQL request\`
  
  GraphQL request:1:12
  1 | query Test @raw_response_type {
    |            ^
  2 |   node(id: "1") {
`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: query-with-raw-response-on-conditional.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query ExampleQuery($id: ID!, $condition: Boolean!) @raw_response_type {
  node(id: $id) {
    ...FriendFragment
  }
}

fragment FriendFragment on User {
  ... @include(if: $condition) {
    name
    lastName
    feedback {
      id
      name
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'raw_response_type'. Source: document \`ExampleQuery\` file: \`GraphQL request\`
  
  GraphQL request:1:52
  1 | query ExampleQuery($id: ID!, $condition: Boolean!) @raw_response_type {
    |                                                    ^
  2 |   node(id: $id) {
`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: query-with-stream.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query TestStream @raw_response_type {
  node(id: "1") {
    ... on User {
      name
      friends(first: 10)
        @stream_connection(
          key: "PaginationFragment_friends"
          initial_count: 1
        ) {
        edges {
          node {
            id
          }
        }
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'raw_response_type'. Source: document \`TestStream\` file: \`GraphQL request\`
  
  GraphQL request:1:18
  1 | query TestStream @raw_response_type {
    |                  ^
  2 |   node(id: "1") {
`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: recursive-fragments.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment FragmentSpread on Node {
  id
  ... @include(if: $condition) {
    ...FragmentSpread
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
type FragmentSpread$ref = any;
export type FragmentSpread$ref = any;
export type FragmentSpread = {
    readonly id: string;
    readonly " $fragmentRefs": FragmentSpread$ref;
    readonly " $refType": FragmentSpread$ref;
};

`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: refetchable-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment RefetchableFragment on Node
  @refetchable(queryName: "RefetchableFragmentQuery") {
  id
  fragAndField: profilePicture {
    uri
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
THROWN EXCEPTION:

Error: RelayParser: Encountered 1 error(s):
- Unknown directive 'refetchable'. Source: document \`RefetchableFragment\` file: \`GraphQL request\`
  
  GraphQL request:2:3
  1 | fragment RefetchableFragment on Node
  2 |   @refetchable(queryName: "RefetchableFragmentQuery") {
    |   ^
  3 |   id
`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: roots.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query ExampleQuery($id: ID!) {
  node(id: $id) {
    id
  }
}

fragment ExampleFragment on User {
  id
}

mutation TestMutation($input: CommentCreateInput!) {
  commentCreate(input: $input) {
    comment {
      id
    }
  }
}

subscription TestSubscription($input: FeedbackLikeInput) {
  feedbackLikeSubscribe(input: $input) {
    feedback {
      id
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
export type ExampleQueryVariables = {
    readonly id: string;
};
export type ExampleQueryResponse = {
    readonly node: {
        readonly id: string;
    } | null;
};
export type ExampleQuery = {
    readonly response: ExampleQueryResponse;
    readonly variables: ExampleQueryVariables;
};


export type ExampleFragment$ref = any;
export type ExampleFragment = {
    readonly id: string;
    readonly " $refType": ExampleFragment$ref;
};


export type CommentCreateInput = {
    readonly clientMutationId?: string | null;
    readonly feedbackId?: string | null;
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type CommentfeedbackFeedback = {
    readonly comment?: FeedbackcommentComment | null;
};
export type FeedbackcommentComment = {
    readonly feedback?: CommentfeedbackFeedback | null;
};
export type TestMutationVariables = {
    readonly input: CommentCreateInput;
};
export type TestMutationResponse = {
    readonly commentCreate: {
        readonly comment: {
            readonly id: string;
        } | null;
    } | null;
};
export type TestMutation = {
    readonly response: TestMutationResponse;
    readonly variables: TestMutationVariables;
};


export type FeedbackLikeInput = {
    readonly clientMutationId?: string | null;
    readonly feedbackId?: string | null;
};
export type TestSubscriptionVariables = {
    readonly input?: FeedbackLikeInput | null;
};
export type TestSubscriptionResponse = {
    readonly feedbackLikeSubscribe: {
        readonly feedback: {
            readonly id: string;
        } | null;
    } | null;
};
export type TestSubscription = {
    readonly response: TestSubscriptionResponse;
    readonly variables: TestSubscriptionVariables;
};

`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: scalar-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment ScalarField on User {
  id
  name
  websites
  traits
  aliasedLinkedField: birthdate {
    aliasedField: year
  }
  screennames {
    name
    service
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
export type PersonalityTraits = "CHEERFUL" | "DERISIVE" | "HELPFUL" | "SNARKY" | "%future added value";
export type ScalarField$ref = any;
export type ScalarField = {
    readonly id: string;
    readonly name: string | null;
    readonly websites: ReadonlyArray<string | null> | null;
    readonly traits: ReadonlyArray<PersonalityTraits | null> | null;
    readonly aliasedLinkedField: {
        readonly aliasedField: number | null;
    } | null;
    readonly screennames: ReadonlyArray<{
        readonly name: string | null;
        readonly service: string | null;
    } | null> | null;
    readonly " $refType": ScalarField$ref;
};

`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: typename-inside-with-overlapping-fields.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment TypenameInsideWithOverlappingFields on Viewer {
  actor {
    __typename
    ... on Page {
      id
      name
    }
    ... on User {
      id
      name
      profile_picture {
        uri
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
export type TypenameInsideWithOverlappingFields$ref = any;
export type TypenameInsideWithOverlappingFields = {
    readonly actor: ({
        readonly __typename: "Page";
        readonly id: string;
        readonly name: string | null;
    } | {
        readonly __typename: "User";
        readonly id: string;
        readonly name: string | null;
        readonly profile_picture: {
            readonly uri: string | null;
        } | null;
    } | {
        /*This will never be '%other', but we need some
        value in case none of the concrete values match.*/
        readonly __typename: "%other";
    }) | null;
    readonly " $refType": TypenameInsideWithOverlappingFields$ref;
};

`;

<<<<<<< HEAD
exports[`TypeScriptGenerator without a single artifact directory matches expected output: typename-inside-with-overlapping-fields-full.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment TypenameInsideWithOverlappingFieldsFull on Viewer {
  actor {
    __typename
    ... on Page {
      id
      name
    }
    ... on User {
      id
      name
      profile_picture {
        uri
      }
    }
    ... on ExtraUser {
      id
      name
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
export type TypenameInsideWithOverlappingFieldsFull$ref = any;
export type TypenameInsideWithOverlappingFieldsFull = {
    readonly actor: ({
        readonly __typename: "Page";
        readonly id: string;
        readonly name: string | null;
    } | {
        readonly __typename: "User";
        readonly id: string;
        readonly name: string | null;
        readonly profile_picture: {
            readonly uri: string | null;
        } | null;
    } | {
        readonly __typename: "ExtraUser";
        readonly id: string;
        readonly name: string | null;
    } | {
        /*This will never be '%other', but we need some
        value in case none of the concrete values match.*/
        readonly __typename: "%other";
    }) | null;
    readonly " $refType": TypenameInsideWithOverlappingFieldsFull$ref;
};

`;

=======
>>>>>>> [test] Update fixtures to those of relay v6
exports[`TypeScriptGenerator without a single artifact directory matches expected output: typename-on-union.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment TypenameInside on Actor {
  ... on User {
    __typename
    firstName
  }
  ... on Page {
    __typename
    username
  }
}

fragment TypenameOutside on Actor {
  __typename
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

fragment TypenameOutsideWithAbstractType on Node {
  __typename
  ... on User {
    firstName
    address {
      street # only here
      city # common
    }
  }
  ... on Actor {
    username
    address {
      city # common
      country # only here
    }
  }
}

fragment TypenameWithoutSpreads on User {
  __typename
  firstName
}

fragment TypenameWithoutSpreadsAbstractType on Node {
  __typename
  id
}

fragment TypenameWithCommonSelections on Actor {
  __typename
  name
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

fragment TypenameAlias on Actor {
  _typeAlias: __typename
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

fragment TypenameAliases on Actor {
  _typeAlias1: __typename
  _typeAlias2: __typename
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
export type TypenameInside$ref = any;
export type TypenameInside = {
    readonly __typename: "User";
    readonly firstName: string | null;
    readonly " $refType": TypenameInside$ref;
} | {
    readonly __typename: "Page";
    readonly username: string | null;
    readonly " $refType": TypenameInside$ref;
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
    readonly " $refType": TypenameInside$ref;
};


export type TypenameOutside$ref = any;
export type TypenameOutside = {
    readonly __typename: "User";
    readonly firstName: string | null;
    readonly " $refType": TypenameOutside$ref;
} | {
    readonly __typename: "Page";
    readonly username: string | null;
    readonly " $refType": TypenameOutside$ref;
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly __typename: "%other";
    readonly " $refType": TypenameOutside$ref;
};


export type TypenameOutsideWithAbstractType$ref = any;
export type TypenameOutsideWithAbstractType = {
    readonly __typename: string;
    readonly username?: string | null;
    readonly address?: {
        readonly city: string | null;
        readonly country: string | null;
        readonly street?: string | null;
    } | null;
    readonly firstName?: string | null;
    readonly " $refType": TypenameOutsideWithAbstractType$ref;
};


export type TypenameWithoutSpreads$ref = any;
export type TypenameWithoutSpreads = {
    readonly firstName: string | null;
    readonly __typename: "User";
    readonly " $refType": TypenameWithoutSpreads$ref;
};


export type TypenameWithoutSpreadsAbstractType$ref = any;
export type TypenameWithoutSpreadsAbstractType = {
    readonly __typename: string;
    readonly id: string;
    readonly " $refType": TypenameWithoutSpreadsAbstractType$ref;
};


export type TypenameWithCommonSelections$ref = any;
export type TypenameWithCommonSelections = {
    readonly __typename: string;
    readonly name: string | null;
    readonly firstName?: string | null;
    readonly username?: string | null;
    readonly " $refType": TypenameWithCommonSelections$ref;
};


export type TypenameAlias$ref = any;
export type TypenameAlias = {
    readonly _typeAlias: "User";
    readonly firstName: string | null;
    readonly " $refType": TypenameAlias$ref;
} | {
    readonly _typeAlias: "Page";
    readonly username: string | null;
    readonly " $refType": TypenameAlias$ref;
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly _typeAlias: "%other";
    readonly " $refType": TypenameAlias$ref;
};


export type TypenameAliases$ref = any;
export type TypenameAliases = {
    readonly _typeAlias1: "User";
    readonly _typeAlias2: "User";
    readonly firstName: string | null;
    readonly " $refType": TypenameAliases$ref;
} | {
    readonly _typeAlias1: "Page";
    readonly _typeAlias2: "Page";
    readonly username: string | null;
    readonly " $refType": TypenameAliases$ref;
} | {
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly _typeAlias1: "%other";
    /*This will never be '%other', but we need some
    value in case none of the concrete values match.*/
    readonly _typeAlias2: "%other";
    readonly " $refType": TypenameAliases$ref;
};

`;

exports[`TypeScriptGenerator without a single artifact directory matches expected output: unmasked-fragment-spreads.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment UserProfile on User {
  profilePicture(size: $ProfilePicture_SIZE) {
    ...PhotoFragment @relay(mask: false)

    # duplicated field should be merged
    ...AnotherRecursiveFragment @relay(mask: false)

    # Compose child fragment
    ...PhotoFragment
  }
}

fragment PhotoFragment on Image {
  uri
  ...RecursiveFragment @relay(mask: false)
}

fragment RecursiveFragment on Image @relay(mask: false) {
  uri
  width
}

fragment AnotherRecursiveFragment on Image {
  uri
  height
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
type PhotoFragment$ref = any;
export type UserProfile$ref = any;
export type UserProfile = {
    readonly profilePicture: {
        readonly uri: string | null;
        readonly width: number | null;
        readonly height: number | null;
        readonly " $fragmentRefs": PhotoFragment$ref;
    } | null;
    readonly " $refType": UserProfile$ref;
};


export type PhotoFragment$ref = any;
export type PhotoFragment = {
    readonly uri: string | null;
    readonly width: number | null;
    readonly " $refType": PhotoFragment$ref;
};


export type RecursiveFragment$ref = any;
export type RecursiveFragment = {
    readonly uri: string | null;
    readonly width: number | null;
};


export type AnotherRecursiveFragment$ref = any;
export type AnotherRecursiveFragment = {
    readonly uri: string | null;
    readonly height: number | null;
    readonly " $refType": AnotherRecursiveFragment$ref;
};

`;
